{"version":3,"file":"angular-touch.min.js","sources":["angular-touch.js"],"names":["window","angular","undefined","nodeName_","element","lowercase","nodeName","makeSwipeDirective","directiveName","direction","eventName","ngTouch","directive","$parse","$swipe","MAX_VERTICAL_DISTANCE","MAX_VERTICAL_RATIO","MIN_HORIZONTAL_DISTANCE","scope","attr","validSwipe","coords","startCoords","deltaY","Math","abs","y","deltaX","x","valid","swipeHandler","pointerTypes","isDefined","push","bind","start","event","cancel","end","$apply","triggerHandler","$event","module","factory","getCoordinates","originalEvent","touches","length","e","changedTouches","clientX","clientY","getEvents","eventType","res","forEach","pointerType","POINTER_EVENTS","join","MOVE_BUFFER_RADIUS","mouse","move","touch","eventHandlers","totalX","totalY","lastPos","active","on","events","preventDefault","config","$provide","decorator","$delegate","shift","$timeout","$rootElement","hit","x1","y1","x2","y2","CLICKBUSTER_THRESHOLD","checkAllowableRegions","touchCoordinates","i","splice","onClick","Date","now","lastPreventedTime","PREVENT_DURATION","lastLabelClickCoordinates","target","stopPropagation","blur","onTouchStart","preventGhostClick","addEventListener","TAP_DURATION","MOVE_TOLERANCE","ACTIVE_CLASS_NAME","resetState","tapping","removeClass","tapElement","startTime","touchStartX","touchStartY","clickHandler","ngClick","srcElement","nodeType","parentNode","addClass","diff","dist","sqrt","pow","disabled","onclick","touchend"],"mappings":"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","sourcesContent":["/**\r\n * @license AngularJS v1.4.7\r\n * (c) 2010-2015 Google, Inc. http://angularjs.org\r\n * License: MIT\r\n */\r\n(function(window, angular, undefined) {'use strict';\r\n\r\n/**\r\n * @ngdoc module\r\n * @name ngTouch\r\n * @description\r\n *\r\n * # ngTouch\r\n *\r\n * The `ngTouch` module provides touch events and other helpers for touch-enabled devices.\r\n * The implementation is based on jQuery Mobile touch event handling\r\n * ([jquerymobile.com](http://jquerymobile.com/)).\r\n *\r\n *\r\n * See {@link ngTouch.$swipe `$swipe`} for usage.\r\n *\r\n * <div doc-module-components=\"ngTouch\"></div>\r\n *\r\n */\r\n\r\n// define ngTouch module\r\n/* global -ngTouch */\r\nvar ngTouch = angular.module('ngTouch', []);\r\n\r\nfunction nodeName_(element) {\r\n  return angular.lowercase(element.nodeName || (element[0] && element[0].nodeName));\r\n}\r\n\r\n/* global ngTouch: false */\r\n\r\n    /**\r\n     * @ngdoc service\r\n     * @name $swipe\r\n     *\r\n     * @description\r\n     * The `$swipe` service is a service that abstracts the messier details of hold-and-drag swipe\r\n     * behavior, to make implementing swipe-related directives more convenient.\r\n     *\r\n     * Requires the {@link ngTouch `ngTouch`} module to be installed.\r\n     *\r\n     * `$swipe` is used by the `ngSwipeLeft` and `ngSwipeRight` directives in `ngTouch`, and by\r\n     * `ngCarousel` in a separate component.\r\n     *\r\n     * # Usage\r\n     * The `$swipe` service is an object with a single method: `bind`. `bind` takes an element\r\n     * which is to be watched for swipes, and an object with four handler functions. See the\r\n     * documentation for `bind` below.\r\n     */\r\n\r\nngTouch.factory('$swipe', [function() {\r\n  // The total distance in any direction before we make the call on swipe vs. scroll.\r\n  var MOVE_BUFFER_RADIUS = 10;\r\n\r\n  var POINTER_EVENTS = {\r\n    'mouse': {\r\n      start: 'mousedown',\r\n      move: 'mousemove',\r\n      end: 'mouseup'\r\n    },\r\n    'touch': {\r\n      start: 'touchstart',\r\n      move: 'touchmove',\r\n      end: 'touchend',\r\n      cancel: 'touchcancel'\r\n    }\r\n  };\r\n\r\n  function getCoordinates(event) {\r\n    var originalEvent = event.originalEvent || event;\r\n    var touches = originalEvent.touches && originalEvent.touches.length ? originalEvent.touches : [originalEvent];\r\n    var e = (originalEvent.changedTouches && originalEvent.changedTouches[0]) || touches[0];\r\n\r\n    return {\r\n      x: e.clientX,\r\n      y: e.clientY\r\n    };\r\n  }\r\n\r\n  function getEvents(pointerTypes, eventType) {\r\n    var res = [];\r\n    angular.forEach(pointerTypes, function(pointerType) {\r\n      var eventName = POINTER_EVENTS[pointerType][eventType];\r\n      if (eventName) {\r\n        res.push(eventName);\r\n      }\r\n    });\r\n    return res.join(' ');\r\n  }\r\n\r\n  return {\r\n    /**\r\n     * @ngdoc method\r\n     * @name $swipe#bind\r\n     *\r\n     * @description\r\n     * The main method of `$swipe`. It takes an element to be watched for swipe motions, and an\r\n     * object containing event handlers.\r\n     * The pointer types that should be used can be specified via the optional\r\n     * third argument, which is an array of strings `'mouse'` and `'touch'`. By default,\r\n     * `$swipe` will listen for `mouse` and `touch` events.\r\n     *\r\n     * The four events are `start`, `move`, `end`, and `cancel`. `start`, `move`, and `end`\r\n     * receive as a parameter a coordinates object of the form `{ x: 150, y: 310 }` and the raw\r\n     * `event`. `cancel` receives the raw `event` as its single parameter.\r\n     *\r\n     * `start` is called on either `mousedown` or `touchstart`. After this event, `$swipe` is\r\n     * watching for `touchmove` or `mousemove` events. These events are ignored until the total\r\n     * distance moved in either dimension exceeds a small threshold.\r\n     *\r\n     * Once this threshold is exceeded, either the horizontal or vertical delta is greater.\r\n     * - If the horizontal distance is greater, this is a swipe and `move` and `end` events follow.\r\n     * - If the vertical distance is greater, this is a scroll, and we let the browser take over.\r\n     *   A `cancel` event is sent.\r\n     *\r\n     * `move` is called on `mousemove` and `touchmove` after the above logic has determined that\r\n     * a swipe is in progress.\r\n     *\r\n     * `end` is called when a swipe is successfully completed with a `touchend` or `mouseup`.\r\n     *\r\n     * `cancel` is called either on a `touchcancel` from the browser, or when we begin scrolling\r\n     * as described above.\r\n     *\r\n     */\r\n    bind: function(element, eventHandlers, pointerTypes) {\r\n      // Absolute total movement, used to control swipe vs. scroll.\r\n      var totalX, totalY;\r\n      // Coordinates of the start position.\r\n      var startCoords;\r\n      // Last event's position.\r\n      var lastPos;\r\n      // Whether a swipe is active.\r\n      var active = false;\r\n\r\n      pointerTypes = pointerTypes || ['mouse', 'touch'];\r\n      element.on(getEvents(pointerTypes, 'start'), function(event) {\r\n        startCoords = getCoordinates(event);\r\n        active = true;\r\n        totalX = 0;\r\n        totalY = 0;\r\n        lastPos = startCoords;\r\n        eventHandlers['start'] && eventHandlers['start'](startCoords, event);\r\n      });\r\n      var events = getEvents(pointerTypes, 'cancel');\r\n      if (events) {\r\n        element.on(events, function(event) {\r\n          active = false;\r\n          eventHandlers['cancel'] && eventHandlers['cancel'](event);\r\n        });\r\n      }\r\n\r\n      element.on(getEvents(pointerTypes, 'move'), function(event) {\r\n        if (!active) return;\r\n\r\n        // Android will send a touchcancel if it thinks we're starting to scroll.\r\n        // So when the total distance (+ or - or both) exceeds 10px in either direction,\r\n        // we either:\r\n        // - On totalX > totalY, we send preventDefault() and treat this as a swipe.\r\n        // - On totalY > totalX, we let the browser handle it as a scroll.\r\n\r\n        if (!startCoords) return;\r\n        var coords = getCoordinates(event);\r\n\r\n        totalX += Math.abs(coords.x - lastPos.x);\r\n        totalY += Math.abs(coords.y - lastPos.y);\r\n\r\n        lastPos = coords;\r\n\r\n        if (totalX < MOVE_BUFFER_RADIUS && totalY < MOVE_BUFFER_RADIUS) {\r\n          return;\r\n        }\r\n\r\n        // One of totalX or totalY has exceeded the buffer, so decide on swipe vs. scroll.\r\n        if (totalY > totalX) {\r\n          // Allow native scrolling to take over.\r\n          active = false;\r\n          eventHandlers['cancel'] && eventHandlers['cancel'](event);\r\n          return;\r\n        } else {\r\n          // Prevent the browser from scrolling.\r\n          event.preventDefault();\r\n          eventHandlers['move'] && eventHandlers['move'](coords, event);\r\n        }\r\n      });\r\n\r\n      element.on(getEvents(pointerTypes, 'end'), function(event) {\r\n        if (!active) return;\r\n        active = false;\r\n        eventHandlers['end'] && eventHandlers['end'](getCoordinates(event), event);\r\n      });\r\n    }\r\n  };\r\n}]);\r\n\r\n/* global ngTouch: false,\r\n  nodeName_: false\r\n*/\r\n\r\n/**\r\n * @ngdoc directive\r\n * @name ngClick\r\n *\r\n * @description\r\n * A more powerful replacement for the default ngClick designed to be used on touchscreen\r\n * devices. Most mobile browsers wait about 300ms after a tap-and-release before sending\r\n * the click event. This version handles them immediately, and then prevents the\r\n * following click event from propagating.\r\n *\r\n * Requires the {@link ngTouch `ngTouch`} module to be installed.\r\n *\r\n * This directive can fall back to using an ordinary click event, and so works on desktop\r\n * browsers as well as mobile.\r\n *\r\n * This directive also sets the CSS class `ng-click-active` while the element is being held\r\n * down (by a mouse click or touch) so you can restyle the depressed element if you wish.\r\n *\r\n * @element ANY\r\n * @param {expression} ngClick {@link guide/expression Expression} to evaluate\r\n * upon tap. (Event object is available as `$event`)\r\n *\r\n * @example\r\n    <example module=\"ngClickExample\" deps=\"angular-touch.js\">\r\n      <file name=\"index.html\">\r\n        <button ng-click=\"count = count + 1\" ng-init=\"count=0\">\r\n          Increment\r\n        </button>\r\n        count: {{ count }}\r\n      </file>\r\n      <file name=\"script.js\">\r\n        angular.module('ngClickExample', ['ngTouch']);\r\n      </file>\r\n    </example>\r\n */\r\n\r\nngTouch.config(['$provide', function($provide) {\r\n  $provide.decorator('ngClickDirective', ['$delegate', function($delegate) {\r\n    // drop the default ngClick directive\r\n    $delegate.shift();\r\n    return $delegate;\r\n  }]);\r\n}]);\r\n\r\nngTouch.directive('ngClick', ['$parse', '$timeout', '$rootElement',\r\n    function($parse, $timeout, $rootElement) {\r\n  var TAP_DURATION = 750; // Shorter than 750ms is a tap, longer is a taphold or drag.\r\n  var MOVE_TOLERANCE = 12; // 12px seems to work in most mobile browsers.\r\n  var PREVENT_DURATION = 2500; // 2.5 seconds maximum from preventGhostClick call to click\r\n  var CLICKBUSTER_THRESHOLD = 25; // 25 pixels in any dimension is the limit for busting clicks.\r\n\r\n  var ACTIVE_CLASS_NAME = 'ng-click-active';\r\n  var lastPreventedTime;\r\n  var touchCoordinates;\r\n  var lastLabelClickCoordinates;\r\n\r\n\r\n  // TAP EVENTS AND GHOST CLICKS\r\n  //\r\n  // Why tap events?\r\n  // Mobile browsers detect a tap, then wait a moment (usually ~300ms) to see if you're\r\n  // double-tapping, and then fire a click event.\r\n  //\r\n  // This delay sucks and makes mobile apps feel unresponsive.\r\n  // So we detect touchstart, touchcancel and touchend ourselves and determine when\r\n  // the user has tapped on something.\r\n  //\r\n  // What happens when the browser then generates a click event?\r\n  // The browser, of course, also detects the tap and fires a click after a delay. This results in\r\n  // tapping/clicking twice. We do \"clickbusting\" to prevent it.\r\n  //\r\n  // How does it work?\r\n  // We attach global touchstart and click handlers, that run during the capture (early) phase.\r\n  // So the sequence for a tap is:\r\n  // - global touchstart: Sets an \"allowable region\" at the point touched.\r\n  // - element's touchstart: Starts a touch\r\n  // (- touchcancel ends the touch, no click follows)\r\n  // - element's touchend: Determines if the tap is valid (didn't move too far away, didn't hold\r\n  //   too long) and fires the user's tap handler. The touchend also calls preventGhostClick().\r\n  // - preventGhostClick() removes the allowable region the global touchstart created.\r\n  // - The browser generates a click event.\r\n  // - The global click handler catches the click, and checks whether it was in an allowable region.\r\n  //     - If preventGhostClick was called, the region will have been removed, the click is busted.\r\n  //     - If the region is still there, the click proceeds normally. Therefore clicks on links and\r\n  //       other elements without ngTap on them work normally.\r\n  //\r\n  // This is an ugly, terrible hack!\r\n  // Yeah, tell me about it. The alternatives are using the slow click events, or making our users\r\n  // deal with the ghost clicks, so I consider this the least of evils. Fortunately Angular\r\n  // encapsulates this ugly logic away from the user.\r\n  //\r\n  // Why not just put click handlers on the element?\r\n  // We do that too, just to be sure. If the tap event caused the DOM to change,\r\n  // it is possible another element is now in that position. To take account for these possibly\r\n  // distinct elements, the handlers are global and care only about coordinates.\r\n\r\n  // Checks if the coordinates are close enough to be within the region.\r\n  function hit(x1, y1, x2, y2) {\r\n    return Math.abs(x1 - x2) < CLICKBUSTER_THRESHOLD && Math.abs(y1 - y2) < CLICKBUSTER_THRESHOLD;\r\n  }\r\n\r\n  // Checks a list of allowable regions against a click location.\r\n  // Returns true if the click should be allowed.\r\n  // Splices out the allowable region from the list after it has been used.\r\n  function checkAllowableRegions(touchCoordinates, x, y) {\r\n    for (var i = 0; i < touchCoordinates.length; i += 2) {\r\n      if (hit(touchCoordinates[i], touchCoordinates[i + 1], x, y)) {\r\n        touchCoordinates.splice(i, i + 2);\r\n        return true; // allowable region\r\n      }\r\n    }\r\n    return false; // No allowable region; bust it.\r\n  }\r\n\r\n  // Global click handler that prevents the click if it's in a bustable zone and preventGhostClick\r\n  // was called recently.\r\n  function onClick(event) {\r\n    if (Date.now() - lastPreventedTime > PREVENT_DURATION) {\r\n      return; // Too old.\r\n    }\r\n\r\n    var touches = event.touches && event.touches.length ? event.touches : [event];\r\n    var x = touches[0].clientX;\r\n    var y = touches[0].clientY;\r\n    // Work around desktop Webkit quirk where clicking a label will fire two clicks (on the label\r\n    // and on the input element). Depending on the exact browser, this second click we don't want\r\n    // to bust has either (0,0), negative coordinates, or coordinates equal to triggering label\r\n    // click event\r\n    if (x < 1 && y < 1) {\r\n      return; // offscreen\r\n    }\r\n    if (lastLabelClickCoordinates &&\r\n        lastLabelClickCoordinates[0] === x && lastLabelClickCoordinates[1] === y) {\r\n      return; // input click triggered by label click\r\n    }\r\n    // reset label click coordinates on first subsequent click\r\n    if (lastLabelClickCoordinates) {\r\n      lastLabelClickCoordinates = null;\r\n    }\r\n    // remember label click coordinates to prevent click busting of trigger click event on input\r\n    if (nodeName_(event.target) === 'label') {\r\n      lastLabelClickCoordinates = [x, y];\r\n    }\r\n\r\n    // Look for an allowable region containing this click.\r\n    // If we find one, that means it was created by touchstart and not removed by\r\n    // preventGhostClick, so we don't bust it.\r\n    if (checkAllowableRegions(touchCoordinates, x, y)) {\r\n      return;\r\n    }\r\n\r\n    // If we didn't find an allowable region, bust the click.\r\n    event.stopPropagation();\r\n    event.preventDefault();\r\n\r\n    // Blur focused form elements\r\n    event.target && event.target.blur && event.target.blur();\r\n  }\r\n\r\n\r\n  // Global touchstart handler that creates an allowable region for a click event.\r\n  // This allowable region can be removed by preventGhostClick if we want to bust it.\r\n  function onTouchStart(event) {\r\n    var touches = event.touches && event.touches.length ? event.touches : [event];\r\n    var x = touches[0].clientX;\r\n    var y = touches[0].clientY;\r\n    touchCoordinates.push(x, y);\r\n\r\n    $timeout(function() {\r\n      // Remove the allowable region.\r\n      for (var i = 0; i < touchCoordinates.length; i += 2) {\r\n        if (touchCoordinates[i] == x && touchCoordinates[i + 1] == y) {\r\n          touchCoordinates.splice(i, i + 2);\r\n          return;\r\n        }\r\n      }\r\n    }, PREVENT_DURATION, false);\r\n  }\r\n\r\n  // On the first call, attaches some event handlers. Then whenever it gets called, it creates a\r\n  // zone around the touchstart where clicks will get busted.\r\n  function preventGhostClick(x, y) {\r\n    if (!touchCoordinates) {\r\n      $rootElement[0].addEventListener('click', onClick, true);\r\n      $rootElement[0].addEventListener('touchstart', onTouchStart, true);\r\n      touchCoordinates = [];\r\n    }\r\n\r\n    lastPreventedTime = Date.now();\r\n\r\n    checkAllowableRegions(touchCoordinates, x, y);\r\n  }\r\n\r\n  // Actual linking function.\r\n  return function(scope, element, attr) {\r\n    var clickHandler = $parse(attr.ngClick),\r\n        tapping = false,\r\n        tapElement,  // Used to blur the element after a tap.\r\n        startTime,   // Used to check if the tap was held too long.\r\n        touchStartX,\r\n        touchStartY;\r\n\r\n    function resetState() {\r\n      tapping = false;\r\n      element.removeClass(ACTIVE_CLASS_NAME);\r\n    }\r\n\r\n    element.on('touchstart', function(event) {\r\n      tapping = true;\r\n      tapElement = event.target ? event.target : event.srcElement; // IE uses srcElement.\r\n      // Hack for Safari, which can target text nodes instead of containers.\r\n      if (tapElement.nodeType == 3) {\r\n        tapElement = tapElement.parentNode;\r\n      }\r\n\r\n      element.addClass(ACTIVE_CLASS_NAME);\r\n\r\n      startTime = Date.now();\r\n\r\n      // Use jQuery originalEvent\r\n      var originalEvent = event.originalEvent || event;\r\n      var touches = originalEvent.touches && originalEvent.touches.length ? originalEvent.touches : [originalEvent];\r\n      var e = touches[0];\r\n      touchStartX = e.clientX;\r\n      touchStartY = e.clientY;\r\n    });\r\n\r\n    element.on('touchcancel', function(event) {\r\n      resetState();\r\n    });\r\n\r\n    element.on('touchend', function(event) {\r\n      var diff = Date.now() - startTime;\r\n\r\n      // Use jQuery originalEvent\r\n      var originalEvent = event.originalEvent || event;\r\n      var touches = (originalEvent.changedTouches && originalEvent.changedTouches.length) ?\r\n          originalEvent.changedTouches :\r\n          ((originalEvent.touches && originalEvent.touches.length) ? originalEvent.touches : [originalEvent]);\r\n      var e = touches[0];\r\n      var x = e.clientX;\r\n      var y = e.clientY;\r\n      var dist = Math.sqrt(Math.pow(x - touchStartX, 2) + Math.pow(y - touchStartY, 2));\r\n\r\n      if (tapping && diff < TAP_DURATION && dist < MOVE_TOLERANCE) {\r\n        // Call preventGhostClick so the clickbuster will catch the corresponding click.\r\n        preventGhostClick(x, y);\r\n\r\n        // Blur the focused element (the button, probably) before firing the callback.\r\n        // This doesn't work perfectly on Android Chrome, but seems to work elsewhere.\r\n        // I couldn't get anything to work reliably on Android Chrome.\r\n        if (tapElement && typeof tapElement.blur === 'function') {\r\n          tapElement.blur();\r\n        }\r\n\r\n        if (!angular.isDefined(attr.disabled) || attr.disabled === false) {\r\n          element.triggerHandler('click', [event]);\r\n        }\r\n      }\r\n\r\n      resetState();\r\n    });\r\n\r\n    // Hack for iOS Safari's benefit. It goes searching for onclick handlers and is liable to click\r\n    // something else nearby.\r\n    element.onclick = function(event) { };\r\n\r\n    // Actual click handler.\r\n    // There are three different kinds of clicks, only two of which reach this point.\r\n    // - On desktop browsers without touch events, their clicks will always come here.\r\n    // - On mobile browsers, the simulated \"fast\" click will call this.\r\n    // - But the browser's follow-up slow click will be \"busted\" before it reaches this handler.\r\n    // Therefore it's safe to use this directive on both mobile and desktop.\r\n    element.on('click', function(event, touchend) {\r\n      scope.$apply(function() {\r\n        clickHandler(scope, {$event: (touchend || event)});\r\n      });\r\n    });\r\n\r\n    element.on('mousedown', function(event) {\r\n      element.addClass(ACTIVE_CLASS_NAME);\r\n    });\r\n\r\n    element.on('mousemove mouseup', function(event) {\r\n      element.removeClass(ACTIVE_CLASS_NAME);\r\n    });\r\n\r\n  };\r\n}]);\r\n\r\n/* global ngTouch: false */\r\n\r\n/**\r\n * @ngdoc directive\r\n * @name ngSwipeLeft\r\n *\r\n * @description\r\n * Specify custom behavior when an element is swiped to the left on a touchscreen device.\r\n * A leftward swipe is a quick, right-to-left slide of the finger.\r\n * Though ngSwipeLeft is designed for touch-based devices, it will work with a mouse click and drag\r\n * too.\r\n *\r\n * To disable the mouse click and drag functionality, add `ng-swipe-disable-mouse` to\r\n * the `ng-swipe-left` or `ng-swipe-right` DOM Element.\r\n *\r\n * Requires the {@link ngTouch `ngTouch`} module to be installed.\r\n *\r\n * @element ANY\r\n * @param {expression} ngSwipeLeft {@link guide/expression Expression} to evaluate\r\n * upon left swipe. (Event object is available as `$event`)\r\n *\r\n * @example\r\n    <example module=\"ngSwipeLeftExample\" deps=\"angular-touch.js\">\r\n      <file name=\"index.html\">\r\n        <div ng-show=\"!showActions\" ng-swipe-left=\"showActions = true\">\r\n          Some list content, like an email in the inbox\r\n        </div>\r\n        <div ng-show=\"showActions\" ng-swipe-right=\"showActions = false\">\r\n          <button ng-click=\"reply()\">Reply</button>\r\n          <button ng-click=\"delete()\">Delete</button>\r\n        </div>\r\n      </file>\r\n      <file name=\"script.js\">\r\n        angular.module('ngSwipeLeftExample', ['ngTouch']);\r\n      </file>\r\n    </example>\r\n */\r\n\r\n/**\r\n * @ngdoc directive\r\n * @name ngSwipeRight\r\n *\r\n * @description\r\n * Specify custom behavior when an element is swiped to the right on a touchscreen device.\r\n * A rightward swipe is a quick, left-to-right slide of the finger.\r\n * Though ngSwipeRight is designed for touch-based devices, it will work with a mouse click and drag\r\n * too.\r\n *\r\n * Requires the {@link ngTouch `ngTouch`} module to be installed.\r\n *\r\n * @element ANY\r\n * @param {expression} ngSwipeRight {@link guide/expression Expression} to evaluate\r\n * upon right swipe. (Event object is available as `$event`)\r\n *\r\n * @example\r\n    <example module=\"ngSwipeRightExample\" deps=\"angular-touch.js\">\r\n      <file name=\"index.html\">\r\n        <div ng-show=\"!showActions\" ng-swipe-left=\"showActions = true\">\r\n          Some list content, like an email in the inbox\r\n        </div>\r\n        <div ng-show=\"showActions\" ng-swipe-right=\"showActions = false\">\r\n          <button ng-click=\"reply()\">Reply</button>\r\n          <button ng-click=\"delete()\">Delete</button>\r\n        </div>\r\n      </file>\r\n      <file name=\"script.js\">\r\n        angular.module('ngSwipeRightExample', ['ngTouch']);\r\n      </file>\r\n    </example>\r\n */\r\n\r\nfunction makeSwipeDirective(directiveName, direction, eventName) {\r\n  ngTouch.directive(directiveName, ['$parse', '$swipe', function($parse, $swipe) {\r\n    // The maximum vertical delta for a swipe should be less than 75px.\r\n    var MAX_VERTICAL_DISTANCE = 75;\r\n    // Vertical distance should not be more than a fraction of the horizontal distance.\r\n    var MAX_VERTICAL_RATIO = 0.3;\r\n    // At least a 30px lateral motion is necessary for a swipe.\r\n    var MIN_HORIZONTAL_DISTANCE = 30;\r\n\r\n    return function(scope, element, attr) {\r\n      var swipeHandler = $parse(attr[directiveName]);\r\n\r\n      var startCoords, valid;\r\n\r\n      function validSwipe(coords) {\r\n        // Check that it's within the coordinates.\r\n        // Absolute vertical distance must be within tolerances.\r\n        // Horizontal distance, we take the current X - the starting X.\r\n        // This is negative for leftward swipes and positive for rightward swipes.\r\n        // After multiplying by the direction (-1 for left, +1 for right), legal swipes\r\n        // (ie. same direction as the directive wants) will have a positive delta and\r\n        // illegal ones a negative delta.\r\n        // Therefore this delta must be positive, and larger than the minimum.\r\n        if (!startCoords) return false;\r\n        var deltaY = Math.abs(coords.y - startCoords.y);\r\n        var deltaX = (coords.x - startCoords.x) * direction;\r\n        return valid && // Short circuit for already-invalidated swipes.\r\n            deltaY < MAX_VERTICAL_DISTANCE &&\r\n            deltaX > 0 &&\r\n            deltaX > MIN_HORIZONTAL_DISTANCE &&\r\n            deltaY / deltaX < MAX_VERTICAL_RATIO;\r\n      }\r\n\r\n      var pointerTypes = ['touch'];\r\n      if (!angular.isDefined(attr['ngSwipeDisableMouse'])) {\r\n        pointerTypes.push('mouse');\r\n      }\r\n      $swipe.bind(element, {\r\n        'start': function(coords, event) {\r\n          startCoords = coords;\r\n          valid = true;\r\n        },\r\n        'cancel': function(event) {\r\n          valid = false;\r\n        },\r\n        'end': function(coords, event) {\r\n          if (validSwipe(coords)) {\r\n            scope.$apply(function() {\r\n              element.triggerHandler(eventName);\r\n              swipeHandler(scope, {$event: event});\r\n            });\r\n          }\r\n        }\r\n      }, pointerTypes);\r\n    };\r\n  }]);\r\n}\r\n\r\n// Left is negative X-coordinate, right is positive.\r\nmakeSwipeDirective('ngSwipeLeft', -1, 'swipeleft');\r\nmakeSwipeDirective('ngSwipeRight', 1, 'swiperight');\r\n\r\n\r\n\r\n})(window, window.angular);\r\n"]}